## 2.4 Dockerfile

---

**개요**

- 만약, 컨테이너화를 할 때 rough하게 생각하면, 아래와 같습니다.
    1. 아무것도 존재하지 않은 이미지로 컨테이너 생성
    2. 에플리케이션을 위한 환경을 설치하고, 소스코드 등을 복사해 잘 동작하는 것을 확인
    3. 컨테이너를 이미지로 커밋(commit)

- 하지만, 위 방법으로 매번하면 일일이 수작업으로 패키지를 설치하고, 소스코드를 깃에서 복제하거나, 호스트에서 복사해야 합니다.

**대안**

- 도커는 위와 같은 일련의 과정을 손쉽게 기록하고, 수행할 수 있는 빌드(build) 명령어를 제공합니다. 1. 완성된 이미지를 생성하기 위해 컨테이너에 설치해야 하는 패키지, 2. 추가해야 하는 소스코드, 3. 실행해야 하는 명령어와 셸 스크립트 등을 하나의 파일에 기록하면 도커는 작업을 수행한 후 이미지로 만들어냅니다.
- 이런 파일을 **Dockerfile**이라고 하며, 빌드 명령어는 **Dockerfile**을 읽어, 이미지를 생성합니다.

**용도**

- 생성한 이미지를 도커 허브등을 통해 배포할 때, 이미지 자체를 배포하는 대신 이미지를 기록하는 방법을 기록해 놓은 Dockerfile을 배포할 수 있습니다.
- 실제로 도커 허브에 올려져 있는 대부분의 이미지는 Dockerfile을 함께 제공하고 있기 때문입니다.

**의문점**

- 도커를 처음 접하는 사람이라면 "컨테이너에서 작업을 마치고 이미지를 커밋하면 되지 않느냐?"라고 의문을 가질 수 있습니다 ( **저임** )
- 그러나 애플리케이션을 컨테이너화하기 위한 장기적인 시점에서 본다면 Dockerfile을 작성하는 것은 이미지를 생성하는 방법을 기록하는 것 뿐만 아니라 이미지의 빌드, 배포 측면에서도 매우 유리합니다. ( 왜 유리한거지? )

## 2.4.2 Dockerfile 작성

---

**특징**

- Dockerfile에서는 컨테이너에서 수행해야할 작업을 명시합니다. 이 작업을 Dockerfile에 정의하기 위해서는 Dockerfile에서 쓰이는 명령어를 알아둘 필요가 있습니다.
- Dockerfile에서의 명령어는 **도커를 위한 특수한 파일**인 만큼 기존의 스크립트 언어와 비교했을 떄, 새로운 방식입니다만 그렇게 어렵지 않습니다.
- 예시

```docker
FROM ubuntu:14.04
MAINTAINER jeongmin
LABEL "purpose"="practice"
RUN apt-get update
RUN apt-get install apache -y
ADD test.html /var/www/html
WORKDIR /var/www/html
RUN ["/bin/bash", "-c", "echo hello >> test2.html"]
EXPOSE 80
CMD apachectl -DFORGROUND
```

- Dockerfile은 위에서 아래로 한 줄씩 차례대로 실행됩니다. 앞에서 사용한 명령어에 대한 설명은 다음과 같습니다.

**기본 명령어들**

- **FROM**: 생성될 이미지의 베이스가 될 이미지를 뜻합니다. FROM 명령어는 Dockerfile을 작성할 때, 반드시 한 번 이상 입력해야 하며, 이미지 이름의 포맷은 docker run 명령어에서 이미지 이름을 사용했을 때와 같습니다. (사용하는 이미지가 없으면 자동으로 pull 합니다.)
- **MAINTAINER**: 이미지를 생성한 개발자의 정보를 나타냅니다.
- **LABEL**: 이미지에 메타데이터를 추가합니다. 메타 데이터는 '키 값'의 형태로 저장되며, 여러 개의 메타 데이터가 저장될 수 있습니다. 추가된 메타 데이터는 docker inspect 명령어로 이미지의 정보를 구해서 확인할 수 있습니다.
- **RUN**: 이미지를 만들기 위해서 컨테이너 내부에서 명령어를 실행합니다. 예제에서는 apt-get update와 apt-get install apache2 명령어를 실행하기 때문에, 아파치 웹서버가 설치된 이미지가 생성됩니다. 단, Dockefile을 이미지로 빌드하는 과정에서는 별도의 입력이 불가능하기 때문에, apt-get install apache2 명령어에서 설치될 것인지를 Y/N을 Yes로 설정해야합니다. 이미지를 빌드할 때 별도의 입력을 받아야 하는 RUN이 있다면, build 명령어는 이를 오류로 간주하고 빌드를 종료합니다. ( **별도의 입력을 받아야 하는 건지 아닌 지는 어떻게 알 수 있을까?** )
    - RUN은 위처럼 apt-get install 처럼 한 줄의 command로 쓸 수 도 있고,
      RUN ["실행 가능한 파일", "명령줄 인자 1", "명령줄 인자 2", ***] 의 형태로 사용할 수 도 있습니다.
    - 이는 JSON 배열의 입력 형식을 따르기 떄문에 JSON 형식과 일치해야 합니다.
- **ADD/COPY**: 파일을 이미지에 추가합니다. 추가하는 파일은 Dockerfile이 위치한 디렉터리인 컨텍스트(Context)에 가져옵니다. 추가하는 파일은 Dockerfile이 위치한 디렉터리인 컨텍스트(Context)에서 가져옵니다.
  지금 예제에서는 Dockerfile이 위치한 디렉토리에서 가져온다고 생각하면 됩니다,
- **WORKDIR**: 명령어를 실행할 디렉토리를 나타냅니다. Bash 셀에서 cd 명령어를 입력하는 것과 같은 기능을 합니다.
- **EXPOSE**: Dockerfile의 빌드로 생성된 이미지에서 노출할 포트를 설정합니다. 그러나 EXPOSE로 설정한 이미지로 컨테이너를 생성했다고 해서 이 포트가 호스트의 포트와 바인딩 되는 것은 아니며, 단지 컨테이너의 80번 포트를 사용할 것임을 나타낸것 뿐입니다. EXPOSE는 컨테이너를 생성하는 RUN 명령엉에서 모든 노출된 컨테이너의 포트를 호스트에 퍼블리시(Publish)하는 -P 플래그(flag)와 함께 사용됩니다.
- **CMD**: CMD는 컨테이너가 시작될 때마다, 실행할 명령어(커맨드)를 설정하며, Dockerfile에서 한 번만 사용할 수 있습니다. Dockerfile에 CMD를 명시함으로서, 컨테이너를 생성할 때 별도의 커맨드를 입력하지않아도, 해당하는 커맨드가 적용되어 컨테이너가 시작될 것입니다.

## 2.4.3 Docker 빌드 컨텍스트

---

- 이미지 빌드를 시작하면 도커는 가장 먼저 빌드 컨텍스트를 읽습니다. 빌드 컨텍스트는 이미지를 생성하는 데 필요한 각종 파일, 소스코드, 메타데이터 등을 담고 있는 디렉터리를 의미하며, Dockerfile이 위치한 디렉토리가 빌드 컨텍스트가 됩니다.
- 컨텍스트는 build 명령어의 맨 마지막의 지정된 위치에 있는 파일을 전부 포함합니다. 깃(Git) 과 같은 외부 URL에서 Dockerfile을 읽는다면, 해당 저장소에 있는 파일과 서브 모듈을 포함합니다 따라서 Dockerfile이 위치한 곳에는 이미지 빌드에 필요한 파일만 있는 것이 바람직합니다. **루트 디렉터리 같은 곳에서 이미지를 빌드하지 않도록 주의해야** 합니다. 빌드에 불필요한 파일이 포함된다면 빌드 속도가 느려질 뿐더러, 호스트의 메모리를 지나치게 점유할 수 있습니다.
- 좀 더 효율적이게 하기 위해선 .gitignore와 유사한 .dockerignore라는 파일을 작성할 수도 있습니다. 빌드시 이 파일에 명시된 이름의 파일을 컨텍스트에서 제외합니다.
- 예시

    ```docker
    test2.html
    *.html
    */*.html
    test.htm?
    ```

  ⇒ '*' : 해당하는 모든 파일을 뜻합니다.

  ⇒ '?' : 앞을 접두어로 두고, "?" 자리에 임의이 1자리 문자가 들어가는 파일을 제외한다 라는 뜻입니다.

  ⇒ ' !': 특정 파일을 제외하지 않음을 뜻합니다.

- Dockerfile을 이용한 컨테이너 생성과 커밋
    - build 명령어는 Dockerfile에 기록된 대로 컨테이너를 실행한 뒤 완성된 이미지를 만들어 냅니다.