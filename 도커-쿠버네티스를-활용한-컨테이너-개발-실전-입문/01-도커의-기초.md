# 도커의 기초

- [도커의 기초](#도커의-기초)
- [1. 도커란 무엇인가?](#1-도커란-무엇인가)
  - [1.1. 도커의 기본 개념](#11-도커의-기본-개념)
- [1.2. 도커 스타일 체험](#12-도커-스타일-체험)
- [2. 도커를 사용하는 의의](#2-도커를-사용하는-의의)
  - [2.1. 환경 차이로 인한 문제 방지](#21-환경-차이로-인한-문제-방지)
  - [2.2. 애플리케이션 구성 관리의 용이성](#22-애플리케이션-구성-관리의-용이성)
- [3. 리얼 도커 환경 구축하기](#3-리얼-도커-환경-구축하기)

# 1. 도커란 무엇인가?

**도커의 구성**
- 컨테이너형 가상화 기술을 구현하기 위한 상주 애플리케이션 (dockered 라는 데몬이 상주 실행)
- 애플리케이션을 조작하기 위한 명령형 도구 (CLI)

**도커의 특징**
- 애플리케이션 배포에 특화
- 애플리케이션 개발 및 운영을 컨테이너 중심으로 할 수 있음

**컨테이너**
- 도커가 만들어내는 게스트 운영 체제

**도커의 활용 예시**
- 과거엔 웹 서버를 구축하기 위해 가상 환경과 운영 환경에 같은 OS 를 설치하고 이것저것 환경 세팅 해줘야함
- 만약 이런 서버를 여러 개 구축한다면 일일히 다 해줘야 했음
- 도커가 등장하면서, 로컬 환경에 도커만 설치하면 몇 줄짜리 구성 파일 (`Dockerfile`) 과 명령어 한 줄 만으로 가상환경 (도커 컨테이너) 를 구출할 수 있음
- 개발 환경 구축 뿐만 아니라 개발 후 운영 환경에 대한 배포 기능도 더 뛰어남
- 가벼워서 운영 환경에서도 컨테이너 사용 가능
- 이식성이 뛰어나서 서로 다른 서버에 있는 도커 환경에 배포 가능하기 때문에 개발 환경과 운영 환경을 거의 동등하게 재현 가능

**도커가 적합하지 않은 경우**
- 컨테이너는 운영 체제의 동작을 완전히 재현하지 못하기 때문에 좀 더 엄밀한 리눅스 계열 운영 체제의 동작이 요구되는 가상 환경에서는 기존처럼 VMWare 나 VirtualBox 같은 가상화 소프트웨어를 사용하는 것이 나음
- FreeBSD 같은 비리눅스 환경도 적합하지 않음

<br>

## 1.1. 도커의 기본 개념

**컨테이너형 가상화 기술**
- 운영 체제 수준 가상화 (Operating-system-level virtualization) 이라고도 함
- 가상화 소프트웨어 없이도 운영 체제의 리소스를 격리해 가상 운영 체제 (**컨테이너**) 로 만들 수 있음
- 호스트 운영 체제 가상화
  - 운영 체제 위에서 가상화 소프트웨어를 사용해 하드웨어를 에뮬레이션 하는 방법으로 게스트 운영 체제를 만드는 방식
  - VMWare Player, Oracle VirtualBox 등
  - 컨테이너형 가상화 기술과 비교하면 오버헤드가 더 큼

**LXC 와 비교했을 때 도커의 장점**
- 호스트 운영 체제의 영향을 받지 않는 실행 환경 (Docker Engine 을 이용한 실행 환경 표준화)
- DSL (Dockerfile) 을 이용한 컨테이너 구성 및 애플리케이션 배포 정의
- 이미지 버전 관리
- 레이어 구조를 갖는 이미지 포맷 (차분 빌드 가능)
- 도커 레지스트리 (이미지 저장 서버 역할)
- 프로그램 가능한 다양한 기능의 API

**도커와 기존 가상 머신과의 차이점**
- 가볍다
- 이식성이 좋다
- 도커엔진을 이용하여 호스트 OS 의 커널을 갖다 쓰기 때문에 별도의 게스트 OS 를 따로 설치하지 않아도 됨
- 가상 머신은 호스트 OS - 게스트 OS 간의 조절을 위해 하이퍼바이저를 사용해야 하는데 이게 무겁다

**결론**
- 도커 이전에는 애플리케이션을 호스트 운영 체제 또는 게스트 운영 체제에 배포하는 스타일이 주류
- 위 방식은 애플리케이션이 운영 체제의 영향을 강하게 받음
- 반면 도커는 컨테이너에 애플리케이션 실행 환경이 함께 배포
- 아예 실행 환경째로 배포하기 때문에 골치 아픈 환경별 의존성 문제를 근본적으로 해결
- 배포도 간단하고 이식성이 높음
  - 도커만 설치되어 있다면 CentOS 에 최적화된 애플리케이션을 Ubuntu 서버에 설치 가능

<br>

# 1.2. 도커 스타일 체험

도커를 설치하지 않고 간단히 도커가 어떤식으로 동작하는지 확인

**1) 애플리케이션 생성**

helloworld 이름의 간단한 스크립트 만들기

```sh
#!/bin/sh

echo "Hello, World!"
```

**2) Dockerfile 작성**

Dockerfile 이나 애플리케이션 실행 파일을 사용해서 도커 컨테이너의 원형이 될 이미지를 만드는 과정을 '도커 이미지 빌드' 라고 함

셸 스크립트와 같은 폴더에 Dockerfile 작성

Dockerfile 에는 도커가 어떻게 이미지를 만들고 실행할지 정의

`FROM`, `COPY`, `RUN` 까지가 도커 빌드 과정에서 실행되어 새로운 이미지를 생성

<br>

```docker
FROM ubuntu:16.04

COPY helloworld /usr/local/bin
RUN chmod +x /usr/local/bin/helloworld

CMD ["helloworld"]
```

- FROM: 컨테이너의 틀 역할을 할 도커 이미지(OS)를 정의
- COPY: 방금 작성한 셸 스크립트 파일 (helloworld) 을 도커 컨테이너 내부의 `/usr/local/bin` 에 복사
- RUN: 도커 컨테이너 안에서 수행할 명령 정의. 여기서는 helloworld 스크립트에 실행 권한 부여
- CMD: 완성된 이미지를 도커 컨테이너로 실행하기 전에 먼저 실행할 명령 정의


**3) 도커 이미지 빌드**

```sh
$ docker image build -t helloworld:latest
Sending build context to Docker daemon 97.5MB
```

Dockerfile 이 있는 폴더에서 실행

**4) 도커 컨테이너 실행**

```sh
$ docker container run helloworld:latest
Hello, world!
```

도커 이미지에 애플리케이션에 필요한 파일을 OS 와 함께 담아서 컨테이너 형태로 실행하는 것이 기본적인 스타일

실제로는 이렇게 한번 출력하고 끝나는게 아니라 계속 실행된 상태의 애플리케이션을 사용하는 경우가 많음

<br>

# 2. 도커를 사용하는 의의

- **변하지 않는 실행 환경**으로 멱등성 (idempotency) 확보
- **코드를 통한** 실행 환경 구축 및 애플리케이션 구성
- 실행 환경과 애플리케이션의 일체화로 **이식성 향상**
- 시스템을 구성하는 애플리케이션 및 미들웨어의 **관리 용이**성

<br>

## 2.1. 환경 차이로 인한 문제 방지

- "B 서버에도 같은 애플리케이션을 배포하고 싶은데，애플리케이션이 A 서버와 다르게 동작하네..."
- "모든 서버에 같은 아카이브를 배포하고 싶은데"
- "서버 설정과 설치된 라이브러리가 서버마다 다르면 어쩌지"
- "B 서버에 설치된 라이브러리가 버전이 낮은 거였네 업데이트해야 겠다!"
- "서버 상태를 똑같이 유지하는 수단이 필요하겠어"

위 상황들은 배포 대상 서버 간에 차이가 있어서 발생하는 문제점

이 문제의 근본적인 원인은 **인프라의 가변성 (mutable infrastructure)** 을 허용하기 때문

애플리케이션은 항상 무언가에 의존: OS, CPU, Memory, Language, Library 등등..

결국 애플리케이션이 의존하는 환경을 가능한 배제하는 것이 문제를 해결하기 위한 방법이고 다음과 같이 2 가지가 존재

<br>

**1) 코드로 관리하는 인프라 (Infrastructure as Code)**

서버 구성, 라이브러리 및 도구 선택을 코드로 정의하고 셰프 (Chef) 나 앤서블 (Ansible) 같은 프로비저닝 도구로 서버를 구축

수작업이 개입할 여지를 줄여서 쉽게 같은 구성의 서버 여러 대를 복제 가능

하지만 코드로 개발하는 것도 만능은 아님

예를 들어 `nodebrew insatll-binary stable` 명령어로 Node.js 버전 관리 도구인 nodebrew 를 설치한다고 가정

`stable` 은 안정된 최신 버전을 설치하는 거라서 자주 바뀔 수 있어서 항상 같은 결과를 보장해야 하는 멱등성이 확보되지 않음

그래서 특정 버전으로 설치해야 하는데 버전을 올릴 때마다 모든 서버에 변경된 구성을 적용해야 해서 운영 업무에 부담을 줄 수 있음

이 문제애 대한 대책이 불변 인프라 개념

<br>

**2) 불변 인프라 (Immutable Infrastrucutre)**

불변 인프라는 **어떤 시점의 서버 상태를 저장해 복제할 수 있게 하자는 개념**

정상적으로 설정된 상태의 서버를 항상 사용할 수 있다는 것이 가장 큰 장점

서버에 변경을 가하고 싶을 땐 기존 인프라를 수정하는 대신 새로운 서버를 구축하고 그 상태를 이미지로 저장 후 복제

한번 설정된 서버는 수정 없이 파기되므로 멱등성을 신경 쓸 필요 없음

<br>

**도커의 활용**

도커를 사용하면 코드로 관리하는 불변 인프라를 간단하고 싸게 실현 가능

인프라 구성이 Dockerfile (도커 이미지) 이라는 코드로 관리됨

컨테이너형 가상화 기술을 사용하기 때문에 게스트 OS 를 사용하는 것과 달리 호스트 OS 를 바로 사용하기 때문에 빠르게 실행 가능

실행 시간이 적기 때문에 수정하는 대신 아예 새로 만드는 불변 인프라와 궁합이 잘 맞음

<br>

**애플리케이션과 인프라 묶어 구축하기**

도커에서 제공하는 인프라 관리와 애플리케이션 배포도 도커의 장점 중 하나

기존 방법은 인프라 구축과 애플리케이션 배포가 별개의 작업이었으나 도커는 인프라와 애플리케이션을 함께 묶은 상자 같은 개념이라 한번에 할 수 있음

그 결과로 높은 이식성으로 인프라와 애플리케이션을 묶어 도커 이미지로 저장해두면 재사용 하거나 다른 서버에서 실행 가능

<br>

## 2.2. 애플리케이션 구성 관리의 용이성

도커 컨테이너는 애플리케이션과 인프라를 함께 담은 상자

일정 규모 이상의 시스템은 여러 개의 애플리케이션으로 구성되므로, 여러 개의 컨테이너로 구성된다고 볼 수 있음

도커는 필요한 컨테이너를 각각 실행하는 방법으로 시스템 구성

하지만 복잡한 시스템을 의존성 문제 없이 한 덩어리로 원활히 동작시키는 것은 쉽지 않음

**도커 컴포즈 (Docker compose)**

- 여러 컨테이너를 사용하는 애플리케이션을 쉽게 관리할 수 있는 도구
- yaml 포맷으로 작성된 설정 파일로 컨테이너를 정의
- 컨테이너 간의 의존 관계를 정의해서 시작 순서를 제어 가능

```yaml
# 웹 애플리케이션과 Redis 컨테이너의 구성 예시

version: "3"
services:
  web:
    image: gihyodocker/web
    ports:
      - "3000:33000"
    environment:
      REDIS_TARGET: redis
    depends_on:
      - redis
  redis:
    image: "redis:alpine"
```

**도커 스웜 (Docker Swarm)**

- 도커 컴포즈가 단일 서버를 넘어 여러 서버에 걸쳐 있는 여러 컨테이너를 관리 가능하게 만드는 도구
- 여러 컨테이너를 관리하는 것만이 목적인 도커 컴포즈와 달리
  - 컨테이너의 증가 혹은 감소
  - 노드의 리소스를 효율적으로 활용하기 위한 컨테이너 배치 및 로드 밸런싱 기능
  - 배포 시 롤링 업데이트 (오래된 컨테이너와 새로운 컨테이너를 단계적으로 서비스에 교체 투입) 이 가능

**도커 컨테이너 오케스트레이션 시스템: 쿠버네티스**

- 이렇게 여러 서버에 걸쳐 있는 여러 컨테이너를 관리하는 기법을 컨테이너 오케스트레이션 (container orchestration) 이라고 함
- 컨테이너 오케스트레이션 분야에서 사실상 표준으로 자리 잡은 것이 쿠버네티스 (Kubernetes)
- 도커 스웜보다 기능이 충실하며 확장성이 높음 (복잡성도 높음)

<br>

# 3. 리얼 도커 환경 구축하기

- 윈도우용/macOS 용 도커 설치
- 윈도우용/macOS 용 도커에는 하이퍼바이저형 가상화 사용
  - OS 자체에 내장된 가상화 시스템을 이용해 오버헤드를 최소한을 억제
- 도커를 이용하면 호스트 OS 위에 여러 도커 컨테이너를 전개하고 이 컨테이너끼리 통신을 주고받는 방식으로 애플리케이션을 구축하는 경우가 많음

**macOS 용 도커 설치**

- [도커 ID 생성](https://hub.docker.com/signup?utm_source=docker&utm_medium=inproductad&utm_campaign=hubimagedetailanonusersignup)
- 다운로드: https://hub.docker.com/editions/community/docker-ce-desktop-mac
- `Docker.dmg` 파일 실행
- Application 폴더에서 Docker 실행
- 처음 실행시 나타나는 주의사항 "Docker needs privileged access" 라는 팝업에서 OK 클릭
- 메뉴 바에 도커 아이콘이 나타나고 "Docker is starting..." 라는 메시지가 나오면 1-2분 정도 기다림
- "Docker is now up and running!" 이라는 메시지 출력되면 준비 완료
- 터미널에서 `docker version` 명령어로 설치 확인

```yml
Client:
 Cloud integration: 1.0.17
 Version:           20.10.7
 API version:       1.41
 Go version:        go1.16.4
 Git commit:        f0df350
 Built:             Wed Jun  2 11:56:22 2021
 OS/Arch:           darwin/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.7
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       b0f5bc3
  Built:            Wed Jun  2 11:54:58 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.6
  GitCommit:        d71fcd7d8303cbf684402823e425e9dd2e99285d
 runc:
  Version:          1.0.0-rc95
  GitCommit:        b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

**도커 기본 설정**

macOS 에서는 상태바에 도커 아이콘을 클릭하고 "Preferences" 를 누르면 설정 가능

- 도커 자동 실행
  - `General > Start docker when you log in` 을 체크하면 운영 체제에 로그인할 때 도커 자동 실행
- 자동 업데이트 확인
  - `General > Automatically check for updates` 체크하면 업데이트 여부를 자동으로 확인
  - 최신 버전을 알려주기만 할 뿐 강제 업데이트는 발생하지 않음
- 호스트 운영체제 디렉터리 마운트
  - `Resources > File Sharing` 탭에서는 도커 컨테이너에 마운트할 호스트 운영 체제의 디렉터리 설정 가능
  - 기본값은 `/Users`, `/Volumes`, `/tmp`, `/private` 으로 되어 있음
  - 설정된 디렉터리 아래에 위치한 디렉터리를 컨테이너에 마운트 가능하며 그 외에는 경고 메세지 출력되며 마운트 되지 않음
- 가상 디스크 용량 설정 / CPU 코어 및 메모리 할당
  - `Resources > Advanced` 탭에서 조절 가능
  - 호스트 운영 체제의 CPU 코어와 메모리 리소스를 얼마나 도커에 할당할지 설정 가능
  - 기본값은 CPUs=2, Memory=2GB 이며 설정된 리소스는 컨테이너 실행 시에만 사용됨
- 프록시
  - `Resources > Proxies` 탭에서 원격 도커 레지스트리에서 도커 이미지를 받아올 (pull) 때 사용할 HTTP/HTTPS 프록시 설정 가능
  - 제한된 대상에만 접근을 허용하는 프라이빗 레지스트리에서 이미지를 받아와야 하는 경우에는 "Manual proxy configuration" 을 설정하면 됨
- Docker Engine
  - 윈도우/macOS 용 도커의 설정하ㅗ면에 나오지 않는 사항을 JSON 포맷으로 설정
- 쿠버네티스
  - 쿠버네티스 사용 활성화 가능
- 도커 재실행 / 모든 데이터 삭제
  - 설정키 우측의 거미 모양 누르면 메뉴 나옴
  - 도커 컨테이너 및 이미지 등 모든 데이터 삭제 가능
  - 도커 제거 가능 (컨테이너 및 이미지 모두 파기)
